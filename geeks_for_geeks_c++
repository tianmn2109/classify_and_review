1: 构造函数和析构函数
    复制构造函数被调用的场合：1：对象被返回。2：对象以传值方式作为函数的参数。
                              3：一个对象以另一个对象为初始值构造。4：编译器产生一个临时对象。
    需要用户自定义复制构造函数的场合：对象含有运行时分配的资源如空间，文件句柄，网络连接等。
    复制构造造造函数可以私有。
    复制构造函数必须以传引用的方式，否则当传值方式传递时，由于函数以传值方式需要调用构造函数，因此会形成调用的递归链。
    复制构造函数参数是const形式，因为1：不应该改变参数的值应将参数设置为const形式。
                                     2：编译器创建的临时对象不能绑定到非const的引用上。因此临时对象随时可能被销毁，
                                        因此修改其无意义。
                                        Test t2 = fun();  此时用func的返回值作为复制构造函数的参数，而返回的临时对象，
                                        所以必须是const类型否则编译器报错。改成Test t2; t2 = fun();不会报错。
    初始化列表对类进行初始化时，按照成员变量在类中的声明顺序初始化。
    使用初始化列表的场合：1:初始化非常量静态数据成员。
                          2：初始化引用数据成员。
                          3：初始化无默认构造函数的成员对象。//此处有疑问
                          4：初始化基类数据成员。
                          5：构造函数参数的名称与成员变量的的名称相同。
                          6: 性能原因。
        析构函数：#include <iostream>
                  using namespace std;
                  int i;
                  class A
                  {
                    public:
                      ~A(){ i=10; } 
                  };
  
                  int foo()
                  {
                    i=3;
                    A ob;
                    return i;
                  }

                  int main()
                  {
                      cout << "i = " << foo() << endl;
                      return 0;
                  }
                  输出结果为3， 因为析构函数是函数最后调用的函数，先return，后调用析构函数。
                  如果要输出10，可以返回引用。
          构造函数：
                  及时用户只实现了复制构造函数，编译器也不会在创建默认的构造函数。反之则不是。
        构造函数不能为虚函数，否则编译器会报错，构造函数最多只能由inline修饰。
        因为c++是静态类型语言，对象的类型是对象在创建的时候由编译器决定的。
        
虚函数：
        1： 默认参数和虚函数。
            默认参数不参与函数签名。所以函数签名只与函数名字有关。默认参数在编译时确定。
            下个例子中，x的值在编译时确定，而func则在运行时确定。结果输出Derived::func(), x = 10.
            class Base
            {
            public:
                virtual void fun ( int x = 0)
               {
                   cout << "Base::fun(), x = " << x << endl;
               }
            };
 
            class Derived : public Base
            {
            public:
               virtual void fun ( int x = 10 ) // NOTE THIS CHANGE
               {
                  cout << "Derived::fun(), x = " << x << endl;
              }
            };
 
 
            int main()
            {
               Derived d1;
              Base *bp = &d1;
               bp->fun();
               return 0;
            }
        静态成员函数不能是虚函数，同样不能用const，volatile来修饰静态成员函数。
        如果通过类对象调用虚函数，因为在编译时就知道了要调用的函数，此时虚函数可以inline。
        而通过指针或者引用调用虚函数是在运行时才能确定调用哪个函数，在这种情况下虚函数不能inline。
        但是在虚函数前加上inline编译器不会报错，是否进行内联，由编译器最终决定。
        纯虚析构函数，必须实现析构函数，因为先调用派生类析构函数在调用基类析构函数，如果没有实现析构函数，
        编译器不知道调用什么。有纯虚析构函数的类是抽象类，虽然其实现了析构函数。
        RTTI (Run-time type information) 要求类中必须有虚函数，只有含有虚函数才有运行时类型信息
        这也就是为什么dynamic_cast要求基类有虚函数。
        
3： 继承
    派生类没有继承父类的东西：基类的构造函数和析构函数2：基类的友元。
    虚继承解决多重继承重复的问题。
    类的成员函数的访问权限是编译时确定的。
    class Base {
        public://改成private编译错误
	            virtual int fun(int i) { cout << "Base::fun(int i) called"; }
            };

    class Derived: public Base {
        private:
            	int fun(int x) { cout << "Derived::fun(int x) called"; }
        };

        int main()
        {   
        	Base *ptr = new Derived;
        	ptr->fun(10);//编译时确定，基类指针，基类是公有，运行时调用派生类的函数
        	return 0;
        }
    如果在派生类中重新定义基类中的方法，则派生类中同名的函数都会被隐藏，即使他们有不同的参数（此种情况下函数签名不同）。

