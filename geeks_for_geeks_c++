1: 构造函数和析构函数
    复制构造函数被调用的场合：1：对象被返回。2：对象以传值方式作为函数的参数。
                              3：一个对象以另一个对象为初始值构造。4：编译器产生一个临时对象。
    需要用户自定义复制构造函数的场合：对象含有运行时分配的资源如空间，文件句柄，网络连接等。
    复制构造造造函数可以私有。
    复制构造函数必须以传引用的方式，否则当传值方式传递时，由于函数以传值方式需要调用构造函数，因此会形成调用的递归链。
    复制构造函数参数是const形式，因为1：不应该改变参数的值应将参数设置为const形式。
                                     2：编译器创建的临时对象不能绑定到非const的引用上。因此临时对象随时可能被销毁，
                                        因此修改其无意义。
                                        Test t2 = fun();  此时用func的返回值作为复制构造函数的参数，而返回的临时对象，
                                        所以必须是const类型否则编译器报错。改成Test t2; t2 = fun();不会报错。
    初始化列表对类进行初始化时，按照成员变量在类中的声明顺序初始化。
    使用初始化列表的场合：1:初始化非常量静态数据成员。
                          2：初始化引用数据成员。
                          3：初始化无默认构造函数的成员对象。//此处有疑问
                          4：初始化基类数据成员。
                          5：构造函数参数的名称与成员变量的的名称相同。
                          6: 性能原因。
        析构函数：#include <iostream>
                  using namespace std;
                  int i;
                  class A
                  {
                    public:
                      ~A(){ i=10; } 
                  };
  
                  int foo()
                  {
                    i=3;
                    A ob;
                    return i;
                  }

                  int main()
                  {
                      cout << "i = " << foo() << endl;
                      return 0;
                  }
                  输出结果为3， 因为析构函数是函数最后调用的函数，先return，后调用析构函数。
                  如果要输出10，可以返回引用。
          构造函数：
                  及时用户只实现了复制构造函数，编译器也不会在创建默认的构造函数。反之则不是。
